/home/xs535-himary/library/main.go

package main

import (
	"library/config"
	"library/routes"

	"github.com/gin-gonic/gin"
)

func init() {
	config.LoadEnvVariables()
	config.ConnectDB()
}

func main() {
	r := gin.Default()
	routes.Routes(r)
	r.Run()
}

/home/xs535-himary/library/.env

PORT=8080
DB_URL="postgres://postgres:password@localhost:5432"
JWT_SECRET=secretkeyjwt

TEST_DB_HOST=localhost
TEST_DB_USER=postgres
TEST_DB_PASSWORD=password
TEST_DB_NAME=test
TEST_DB_PORT=5432


/home/xs535-himary/library/go.mod

module library

go 1.24.0

require (
	github.com/gin-gonic/gin v1.10.0
	github.com/golang-jwt/jwt/v4 v4.5.1
	github.com/joho/godotenv v1.5.1
	golang.org/x/crypto v0.35.0
	gorm.io/driver/postgres v1.5.11
	gorm.io/gorm v1.25.12
)

require (
	github.com/bytedance/sonic v1.12.9 // indirect
	github.com/bytedance/sonic/loader v0.2.3 // indirect
	github.com/cloudwego/base64x v0.1.5 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/gabriel-vasile/mimetype v1.4.8 // indirect
	github.com/gin-contrib/sse v1.0.0 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.25.0 // indirect
	github.com/goccy/go-json v0.10.5 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 // indirect
	github.com/jackc/pgx/v5 v5.7.2 // indirect
	github.com/jackc/puddle/v2 v2.2.2 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/cpuid/v2 v2.2.10 // indirect
	github.com/kr/text v0.2.0 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/pelletier/go-toml/v2 v2.2.3 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/rogpeppe/go-internal v1.14.1 // indirect
	github.com/stretchr/testify v1.10.0 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.2.12 // indirect
	golang.org/x/arch v0.14.0 // indirect
	golang.org/x/net v0.35.0 // indirect
	golang.org/x/sync v0.11.0 // indirect
	golang.org/x/sys v0.30.0 // indirect
	golang.org/x/text v0.22.0 // indirect
	google.golang.org/protobuf v1.36.5 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

/home/xs535-himary/library/go.sum

github.com/bytedance/sonic v1.12.9 h1:Od1BvK55NnewtGaJsTDeAOSnLVO2BTSLOe0+ooKokmQ=
github.com/bytedance/sonic v1.12.9/go.mod h1:uVvFidNmlt9+wa31S1urfwwthTWteBgG0hWuoKAXTx8=
github.com/bytedance/sonic/loader v0.1.1/go.mod h1:ncP89zfokxS5LZrJxl5z0UJcsk4M4yY2JpfqGeCtNLU=
github.com/bytedance/sonic/loader v0.2.3 h1:yctD0Q3v2NOGfSWPLPvG2ggA2kV6TS6s4wioyEqssH0=
github.com/bytedance/sonic/loader v0.2.3/go.mod h1:N8A3vUdtUebEY2/VQC0MyhYeKUFosQU6FxH2JmUe6VI=
github.com/cloudwego/base64x v0.1.5 h1:XPciSp1xaq2VCSt6lF0phncD4koWyULpl5bUxbfCyP4=
github.com/cloudwego/base64x v0.1.5/go.mod h1:0zlkT4Wn5C6NdauXdJRhSKRlJvmclQ1hhJgA0rcu/8w=
github.com/cloudwego/iasm v0.2.0/go.mod h1:8rXZaNYT2n95jn+zTI1sDr+IgcD2GVs0nlbbQPiEFhY=
github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/gabriel-vasile/mimetype v1.4.8 h1:FfZ3gj38NjllZIeJAmMhr+qKL8Wu+nOoI3GqacKw1NM=
github.com/gabriel-vasile/mimetype v1.4.8/go.mod h1:ByKUIKGjh1ODkGM1asKUbQZOLGrPjydw3hYPU2YU9t8=
github.com/gin-contrib/sse v1.0.0 h1:y3bT1mUWUxDpW4JLQg/HnTqV4rozuW4tC9eFKTxYI9E=
github.com/gin-contrib/sse v1.0.0/go.mod h1:zNuFdwarAygJBht0NTKiSi3jRf6RbqeILZ9Sp6Slhe0=
github.com/gin-gonic/gin v1.10.0 h1:nTuyha1TYqgedzytsKYqna+DfLos46nTv2ygFy86HFU=
github.com/gin-gonic/gin v1.10.0/go.mod h1:4PMNQiOhvDRa013RKVbsiNwoyezlm2rm0uX/T7kzp5Y=
github.com/go-playground/assert/v2 v2.2.0 h1:JvknZsQTYeFEAhQwI4qEt9cyV5ONwRHC+lYKSsYSR8s=
github.com/go-playground/assert/v2 v2.2.0/go.mod h1:VDjEfimB/XKnb+ZQfWdccd7VUvScMdVu0Titje2rxJ4=
github.com/go-playground/locales v0.14.1 h1:EWaQ/wswjilfKLTECiXz7Rh+3BjFhfDFKv/oXslEjJA=
github.com/go-playground/locales v0.14.1/go.mod h1:hxrqLVvrK65+Rwrd5Fc6F2O76J/NuW9t0sjnWqG1slY=
github.com/go-playground/universal-translator v0.18.1 h1:Bcnm0ZwsGyWbCzImXv+pAJnYK9S473LQFuzCbDbfSFY=
github.com/go-playground/universal-translator v0.18.1/go.mod h1:xekY+UJKNuX9WP91TpwSH2VMlDf28Uj24BCp08ZFTUY=
github.com/go-playground/validator/v10 v10.25.0 h1:5Dh7cjvzR7BRZadnsVOzPhWsrwUr0nmsZJxEAnFLNO8=
github.com/go-playground/validator/v10 v10.25.0/go.mod h1:GGzBIJMuE98Ic/kJsBXbz1x/7cByt++cQ+YOuDM5wus=
github.com/goccy/go-json v0.10.5 h1:Fq85nIqj+gXn/S5ahsiTlK3TmC85qgirsdTP/+DeaC4=
github.com/goccy/go-json v0.10.5/go.mod h1:oq7eo15ShAhp70Anwd5lgX2pLfOS3QCiwU/PULtXL6M=
github.com/golang-jwt/jwt/v4 v4.5.1 h1:JdqV9zKUdtaa9gdPlywC3aeoEsR681PlKC+4F5gQgeo=
github.com/golang-jwt/jwt/v4 v4.5.1/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w39/MY0Ch0=
github.com/google/go-cmp v0.5.5 h1:Khx7svrCpmxxtHBq5j2mp/xVjsi8hQMfNLvJFAlrGgU=
github.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=
github.com/jackc/pgpassfile v1.0.0 h1:/6Hmqy13Ss2zCq62VdNG8tM1wchn8zjSGOBJ6icpsIM=
github.com/jackc/pgpassfile v1.0.0/go.mod h1:CEx0iS5ambNFdcRtxPj5JhEz+xB6uRky5eyVu/W2HEg=
github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 h1:iCEnooe7UlwOQYpKFhBabPMi4aNAfoODPEFNiAnClxo=
github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761/go.mod h1:5TJZWKEWniPve33vlWYSoGYefn3gLQRzjfDlhSJ9ZKM=
github.com/jackc/pgx/v5 v5.7.2 h1:mLoDLV6sonKlvjIEsV56SkWNCnuNv531l94GaIzO+XI=
github.com/jackc/pgx/v5 v5.7.2/go.mod h1:ncY89UGWxg82EykZUwSpUKEfccBGGYq1xjrOpsbsfGQ=
github.com/jackc/puddle/v2 v2.2.2 h1:PR8nw+E/1w0GLuRFSmiioY6UooMp6KJv0/61nB7icHo=
github.com/jackc/puddle/v2 v2.2.2/go.mod h1:vriiEXHvEE654aYKXXjOvZM39qJ0q+azkZFrfEOc3H4=
github.com/jinzhu/inflection v1.0.0 h1:K317FqzuhWc8YvSVlFMCCUb36O/S9MCKRDI7QkRKD/E=
github.com/jinzhu/inflection v1.0.0/go.mod h1:h+uFLlag+Qp1Va5pdKtLDYj+kHp5pxUVkryuEj+Srlc=
github.com/jinzhu/now v1.1.5 h1:/o9tlHleP7gOFmsnYNz3RGnqzefHA47wQpKrrdTIwXQ=
github.com/jinzhu/now v1.1.5/go.mod h1:d3SSVoowX0Lcu0IBviAWJpolVfI5UJVZZ7cO71lE/z8=
github.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=
github.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=
github.com/json-iterator/go v1.1.12 h1:PV8peI4a0ysnczrg+LtxykD8LfKY9ML6u2jnxaEnrnM=
github.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=
github.com/klauspost/cpuid/v2 v2.0.9/go.mod h1:FInQzS24/EEf25PyTYn52gqo7WaD8xa0213Md/qVLRg=
github.com/klauspost/cpuid/v2 v2.2.10 h1:tBs3QSyvjDyFTq3uoc/9xFpCuOsJQFNPiAhYdw2skhE=
github.com/klauspost/cpuid/v2 v2.2.10/go.mod h1:hqwkgyIinND0mEev00jJYCxPNVRVXFQeu1XKlok6oO0=
github.com/knz/go-libedit v1.10.1/go.mod h1:MZTVkCWyz0oBc7JOWP3wNAzd002ZbM/5hgShxwh4x8M=
github.com/kr/pretty v0.3.0 h1:WgNl7dwNpEZ6jJ9k1snq4pZsg7DOEN8hP9Xw0Tsjwk0=
github.com/kr/pretty v0.3.0/go.mod h1:640gp4NfQd8pI5XOwp5fnNeVWj67G7CFk/SaSQn7NBk=
github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/leodido/go-urn v1.4.0 h1:WT9HwE9SGECu3lg4d/dIA+jxlljEa1/ffXKmRjqdmIQ=
github.com/leodido/go-urn v1.4.0/go.mod h1:bvxc+MVxLKB4z00jd1z+Dvzr47oO32F/QSNjSBOlFxI=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/reflect2 v1.0.2 h1:xBagoLtFs94CBntxluKeaWgTMpvLxC4ur3nMaC9Gz0M=
github.com/modern-go/reflect2 v1.0.2/go.mod h1:yWuevngMOJpCy52FWWMvUC8ws7m/LJsjYzDa0/r8luk=
github.com/pelletier/go-toml/v2 v2.2.3 h1:YmeHyLY8mFWbdkNWwpr+qIL2bEqT0o95WSdkNHvL12M=
github.com/pelletier/go-toml/v2 v2.2.3/go.mod h1:MfCQTFTvCcUyyvvwm1+G6H/jORL20Xlb6rzQu9GuUkc=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/rogpeppe/go-internal v1.14.1 h1:UQB4HGPB6osV0SQTLymcB4TgvyWu6ZyliaW0tI/otEQ=
github.com/rogpeppe/go-internal v1.14.1/go.mod h1:MaRKkUm5W0goXpeCfT7UZI6fk/L7L7so1lCWt35ZSgc=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
github.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
github.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=
github.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=
github.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/twitchyliquid64/golang-asm v0.15.1 h1:SU5vSMR7hnwNxj24w34ZyCi/FmDZTkS4MhqMhdFk5YI=
github.com/twitchyliquid64/golang-asm v0.15.1/go.mod h1:a1lVb/DtPvCB8fslRZhAngC2+aY1QWCk3Cedj/Gdt08=
github.com/ugorji/go/codec v1.2.12 h1:9LC83zGrHhuUA9l16C9AHXAqEV/2wBQ4nkvumAE65EE=
github.com/ugorji/go/codec v1.2.12/go.mod h1:UNopzCgEMSXjBc6AOMqYvWC1ktqTAfzJZUZgYf6w6lg=
golang.org/x/arch v0.14.0 h1:z9JUEZWr8x4rR0OU6c4/4t6E6jOZ8/QBS2bBYBm4tx4=
golang.org/x/arch v0.14.0/go.mod h1:FEVrYAQjsQXMVJ1nsMoVVXPZg6p2JE2mx8psSWTDQys=
golang.org/x/crypto v0.35.0 h1:b15kiHdrGCHrP6LvwaQ3c03kgNhhiMgvlhxHQhmg2Xs=
golang.org/x/crypto v0.35.0/go.mod h1:dy7dXNW32cAb/6/PRuTNsix8T+vJAqvuIy5Bli/x0YQ=
golang.org/x/net v0.35.0 h1:T5GQRQb2y08kTAByq9L4/bz8cipCdA8FbRTXewonqY8=
golang.org/x/net v0.35.0/go.mod h1:EglIi67kWsHKlRzzVMUD93VMSWGFOMSZgxFjparz1Qk=
golang.org/x/sync v0.11.0 h1:GGz8+XQP4FvTTrjZPzNKTMFtSXH80RAzG+5ghFPgK9w=
golang.org/x/sync v0.11.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.30.0 h1:QjkSwP/36a20jFYWkSue1YwXzLmsV5Gfq7Eiy72C1uc=
golang.org/x/sys v0.30.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/text v0.22.0 h1:bofq7m3/HAFvbF51jz3Q9wLg3jkvSPuiZu/pD1XwgtM=
golang.org/x/text v0.22.0/go.mod h1:YRoo4H8PVmsu+E3Ou7cqLVH8oXWIHVoX0jqUWALQhfY=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543 h1:E7g+9GITq07hpfrRu66IVDexMakfv52eLZ2CXBWiKr4=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
google.golang.org/protobuf v1.36.5 h1:tPhr+woSbjfYvY6/GPufUoYizxw1cF/yFoxJ2fmpwlM=
google.golang.org/protobuf v1.36.5/go.mod h1:9fA7Ob0pmnwhb644+1+CVWFRbNajQ6iRojtC/QF5bRE=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gorm.io/driver/postgres v1.5.11 h1:ubBVAfbKEUld/twyKZ0IYn9rSQh448EdelLYk9Mv314=
gorm.io/driver/postgres v1.5.11/go.mod h1:DX3GReXH+3FPWGrrgffdvCk3DQ1dwDPdmbenSkweRGI=
gorm.io/gorm v1.25.12 h1:I0u8i2hWQItBq1WfE0o2+WuL9+8L21K9e2HHSTE/0f8=
gorm.io/gorm v1.25.12/go.mod h1:xh7N7RHfYlNc5EmcI/El95gXusucDrQnHXe0+CgWcLQ=
nullprogram.com/x/optparse v1.0.0/go.mod h1:KdyPE+Igbe0jQUrVfMqDMeJQIJZEuyV7pjYmp6pbG50=


/home/xs535-himary/library/config/database.go
package config

import (
	"fmt"
	"log"
	"os"

	"library/models"

	"github.com/joho/godotenv"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

var DB *gorm.DB

func LoadEnvVariables() {
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
	}
}

func ConnectDB() {
	var err error
	dsn := os.Getenv("DB_URL")
	DB, err = gorm.Open(postgres.Open(dsn), &gorm.Config{})

	if err != nil {
		log.Fatal("Failed to connect to database!")
	}

	// Auto migrate tables
	DB.AutoMigrate(
		&models.User{},
		&models.Session{},
		&models.Library{},
		&models.BookInventory{},
		&models.RequestEvent{},
		&models.IssueRegistery{},
	)

	fmt.Println("Database connected successfully.")
}

/home/xs535-himary/library/controllers/authController.go
package controllers

import (
	"library/config"
	"library/models"
	"library/utils"
	"net/http"
	"strconv"
	"strings"
	"time"

	"regexp"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

// Custom validation for name (only characters allowed)
func isValidName(name string) bool {
	return regexp.MustCompile(`^[A-Za-z\s]+$`).MatchString(name)
}

// Custom password validation (at least 8 characters, 1 uppercase, 1 digit, 1 special character)
func isValidPassword(password string) bool {
	if len(password) < 8 {
		return false
	}
	hasUpper := false
	hasDigit := false
	hasSpecial := false
	for _, char := range password {
		switch {
		case 'A' <= char && char <= 'Z':
			hasUpper = true
		case '0' <= char && char <= '9':
			hasDigit = true
		case strings.ContainsRune("@$!%*?&", char):
			hasSpecial = true
		}
	}
	return hasUpper && hasDigit && hasSpecial
}

// isValidEmail checks if an email follows the correct format
func isValidEmail(email string) bool {
	pattern := `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`
	return regexp.MustCompile(pattern).MatchString(email)
}

// Signup user
func SignUp(c *gin.Context) {
	var user models.User
	// if err := c.ShouldBindJSON(&user); err != nil {
	// 	c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
	// 	return
	// }

	if err := c.ShouldBindJSON(&user); err != nil {
		// fmt.Println()
		// fmt.Println("Binding Error:", err)
		// fmt.Println()
		// fmt.Println("Received JSON:", c.Request.Body) // Debugging output
		// c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()}) // Show the actual error
		utils.RespondJSON(c, http.StatusBadRequest, "Invalid input", gin.H{"error": err.Error()})
		return
	}
	// fmt.Println("Password:", user.Password, "Valid:", isValidPassword(user.Password))

	if user.Role == "admin" {
		var existingAdmin models.User
		if err := config.DB.First(&existingAdmin, "role = ?", "admin").Error; err == nil {
			utils.RespondJSON(c, http.StatusBadRequest, "Cannot create more than one admin", nil)
			return
		} else if err != gorm.ErrRecordNotFound {
			utils.RespondJSON(c, http.StatusInternalServerError, "Failed to fetch users", nil)
			return
		}
	}

	// Validate Name
	if !isValidName(user.Name) {
		// c.JSON(http.StatusBadRequest, gin.H{"error": "Name must contain only letters and spaces"})
		utils.RespondJSON(c, http.StatusBadRequest, "User can not be created", gin.H{"error": "Name must contain only letters and spaces"})
		return
	}

	// Validate Email
	if !isValidEmail(user.Email) {
		// c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid email format"})
		utils.RespondJSON(c, http.StatusBadRequest, "User can not be created", gin.H{"error": "Invalid email format"})
		return
	}

	// Validate Password Strength
	if !isValidPassword(user.Password) {
		// c.JSON(http.StatusBadRequest, gin.H{"error": "Password must be at least 8 characters long, contain one uppercase letter, one number, and one special character"})
		utils.RespondJSON(c, http.StatusBadRequest, "User can not be created", gin.H{"error": "Password must be at least 8 characters long, contain one uppercase letter, one number, and one special character"})
		return
	}

	// Hash password
	hashedPassword, err := utils.HashPassword(user.Password)
	if err != nil {
		// c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to hash password"})
		utils.RespondJSON(c, http.StatusInternalServerError, "Failed to hash password", gin.H{"error": err.Error()})
		return
	}
	user.Password = hashedPassword

	// Save to DB
	if err := config.DB.Create(&user).Error; err != nil {
		// c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create user :-" + err.Error()})
		utils.RespondJSON(c, http.StatusInternalServerError, "Failed to create user", gin.H{"error": err.Error()})
		return
	}

	// c.JSON(http.StatusCreated, gin.H{"message": "User created successfully"})
	utils.RespondJSON(c, http.StatusCreated, "User created successfully", gin.H{"user": user})
}

// SignIn updates to store session
type SignInCredentials struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

func SignIn(c *gin.Context) {
	var credentials SignInCredentials
	if err := c.ShouldBindJSON(&credentials); err != nil {
		// c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
		utils.RespondJSON(c, http.StatusBadRequest, "Invalid input", err.Error())
		return
	}

	// Check if user exists in DB by email
	var user models.User
	if err := config.DB.Where("email = ?", credentials.Email).First(&user).Error; err != nil {
		// c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid email"})
		utils.RespondJSON(c, http.StatusUnauthorized, "Invalid email", nil)
		return
	}

	// Validate password
	if !utils.CheckPasswordHash(credentials.Password, user.Password) {
		// c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid password"})
		utils.RespondJSON(c, http.StatusUnauthorized, "Invalid password", nil)
		return
	}

	// Generate JWT Token
	token, err := utils.GenerateJWT(user.ID, user.Email, user.Role)
	if err != nil {
		// c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate token"})
		utils.RespondJSON(c, http.StatusInternalServerError, "Failed to generate token", nil)
		return
	}

	// Check if there's an existing session, and update or create a new one
	var session models.Session
	// Check if there is an existing active session
	if err := config.DB.Where("user_id = ? AND is_active = ?", user.ID, true).First(&session).Error; err == nil {
		// If a session exists, invalidate it first (or update)
		session.IsActive = false
		config.DB.Save(&session)
	}

	// Create new session for the user
	session = models.Session{
		UserID:    user.ID,
		Token:     token,
		ExpiresAt: time.Now().Add(time.Hour * 24), // Session expiry time
		IsActive:  true,
	}

	// Store the new session in the database
	if err := config.DB.Create(&session).Error; err != nil {
		// c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create session"})
		utils.RespondJSON(c, http.StatusInternalServerError, "Failed to create session", nil)
		return
	}

	// Send response with token and session expiry
	// c.JSON(http.StatusOK, gin.H{
	// 	"token":       token,
	// 	"expiry_time": session.ExpiresAt,
	// 	"message":     "User logged-in successfully",
	// })

	utils.RespondJSON(c, http.StatusOK, "User logged-in successfully !!", gin.H{"token": token, "expiry_time": session.ExpiresAt})
}

// Logout handler
func SignOut(c *gin.Context) {
	authorizationHeader := c.GetHeader("Authorization")

	// Check if the Authorization header is empty or too short
	if len(authorizationHeader) < 8 || authorizationHeader[:7] != "Bearer " {
		utils.RespondJSON(c, http.StatusUnauthorized, "No token provided !!", nil)
		return
	}

	token := authorizationHeader[7:] // Extract the token

	// Check if the token is actually empty
	if token == "" {
		utils.RespondJSON(c, http.StatusUnauthorized, "No token provided !!", nil)
		return
	}

	// Update session status in the database
	result := config.DB.Model(&models.Session{}).Where("token = ?", token).Update("is_active", false)
	if result.Error != nil {
		utils.RespondJSON(c, http.StatusInternalServerError, "Database error while logging out", nil)
		return
	}

	utils.RespondJSON(c, http.StatusOK, "User logged out successfully !!", nil)
}

// GetUsers handles GET requests to fetch all users
func GetUsers(c *gin.Context) {
	var users []models.User
	if err := config.DB.Find(&users).Error; err != nil {
		// c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch users"})
		utils.RespondJSON(c, http.StatusInternalServerError, "Failed to fetch users", nil)
		return
	}
	if len(users) <= 0 {
		utils.RespondJSON(c, http.StatusOK, "No users found in datatbase !!", nil)
		return
	}
	// c.JSON(http.StatusOK, users)
	utils.RespondJSON(c, http.StatusOK, "All users retrived !!", gin.H{"User": users})
}

// GetUserById handles GET requests to fetch a user by ID
func GetUserById(c *gin.Context) {
	id, err := strconv.Atoi(c.Param("id"))
	if err != nil {
		// c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
		utils.RespondJSON(c, http.StatusBadRequest, "Error: Invalid user ID", nil)
		return
	}

	var user models.User
	if err := config.DB.First(&user, id).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			// c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
			utils.RespondJSON(c, http.StatusNotFound, "Error: User not found", nil)
		} else {
			// c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch user"})
			utils.RespondJSON(c, http.StatusInternalServerError, "Error: Failed to fetch user", nil)
		}
		return
	}

	// c.JSON(http.StatusOK, user)
	utils.RespondJSON(c, http.StatusOK, "User retrived !!", gin.H{"User": user})
}

// UpdateUserById handles PUT requests to update a user by ID
func UpdateUserById(c *gin.Context) {
	id, err := strconv.Atoi(c.Param("id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
		return
	}

	var user models.User
	if err := config.DB.First(&user, id).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch user"})
		}
		return
	}

	var updatedUser models.User
	if err := c.ShouldBindJSON(&updatedUser); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
		return
	}

	// Validate Name
	if !isValidName(updatedUser.Name) {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Name must contain only letters and spaces"})
		return
	}

	// Validate Email
	if !isValidEmail(updatedUser.Email) {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid email format"})
		return
	}

	// Validate Password Strength
	if !isValidPassword(updatedUser.Password) {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Password must be at least 8 characters long, contain one uppercase letter, one number, and one special character"})
		return
	}

	// Update only provided fields
	user.Name = updatedUser.Name
	user.Email = updatedUser.Email
	user.ContactNumber = updatedUser.ContactNumber
	user.Role = updatedUser.Role

	// Update password only if provided
	if updatedUser.Password != "" {
		hashedPassword, err := utils.HashPassword(updatedUser.Password)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to hash password"})
			return
		}
		user.Password = hashedPassword
	}

	if err := config.DB.Save(&user).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update user"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "User updated successfully", "user": user})
}

// DeleteUserById handles DELETE requests to delete a user by ID
func DeleteUserById(c *gin.Context) {
	id, err := strconv.Atoi(c.Param("id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
		return
	}

	if err := config.DB.Delete(&models.User{}, id).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete user"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "User deleted successfully"})
}

/home/xs535-himary/library/controllers/bookController.go

package controllers

import (
	"library/config"
	"library/models"
	"library/utils"
	"net/http"

	// "time"

	"github.com/gin-gonic/gin"
)

// Owner: Create Books
func CreateBook(c *gin.Context) {
	var book models.BookInventory
	if err := c.ShouldBindJSON(&book); err != nil {
		utils.RespondJSON(c, http.StatusBadRequest, "Invalid input", nil)
		return
	}

	//find user by id
	var user models.User
	if err := config.DB.First(&user, c.GetUint("user_id")).Error; err != nil {
		utils.RespondJSON(c, http.StatusNotFound, "User not found For Getting LibID", nil)
		return
	}

	//the user should be owner to create book
	//update user lib_id of the book
	book.LibID = user.LibID
	if err := config.DB.Create(&book).Error; err != nil {
		utils.RespondJSON(c, http.StatusInternalServerError, "Failed to create book", nil)
		return
	}

	utils.RespondJSON(c, http.StatusCreated, "Book created successfully", book)
}

// Everyone can get a book
func GetBooks(c *gin.Context) {
	var books []models.BookInventory
	config.DB.Find(&books)
	utils.RespondJSON(c, http.StatusOK, "Books retrieved successfully", books)
}

func GetBookByID(c *gin.Context) {
	var book models.BookInventory
	bookID := c.Param("id")

	if err := config.DB.First(&book, "isbn = ?", bookID).Error; err != nil {
		utils.RespondJSON(c, http.StatusNotFound, "Book not found", nil)
		return
	}

	utils.RespondJSON(c, http.StatusOK, "Book retrieved successfully", book)
}

// // Admin: Update Book by ID
func UpdateBookByID(c *gin.Context) {
	var book models.BookInventory
	bookID := c.Param("id")

	// Check if the book exists
	if err := config.DB.First(&book, "isbn = ?", bookID).Error; err != nil {
		utils.RespondJSON(c, http.StatusNotFound, "Book not found", nil)
		return
	}

	// Create a map for updating only allowed fields
	var updateData map[string]interface{}
	if err := c.ShouldBindJSON(&updateData); err != nil {
		utils.RespondJSON(c, http.StatusBadRequest, "Invalid input", nil)
		return
	}

	// Prevent BookID from being updated
	delete(updateData, "book_id")

	// Update only the fields provided in JSON
	if err := config.DB.Model(&book).Updates(updateData).Error; err != nil {
		utils.RespondJSON(c, http.StatusInternalServerError, "Failed to update book", nil)
		return
	}

	utils.RespondJSON(c, http.StatusOK, "Book updated successfully", book)
}

// Admin: Delete Book by ID
func DeleteBookByID(c *gin.Context) {
	var book models.BookInventory
	bookID := c.Param("id")

	// Check if the book exists
	if err := config.DB.First(&book, "isbn = ?", bookID).Error; err != nil {
		utils.RespondJSON(c, http.StatusNotFound, "Book not found", nil)
		return
	}

	// Delete book
	if err := config.DB.Delete(&book).Error; err != nil {
		utils.RespondJSON(c, http.StatusInternalServerError, "Failed to delete book", nil)
		return
	}

	utils.RespondJSON(c, http.StatusOK, "Book deleted successfully", nil)
}

func SearchBooks(c *gin.Context) {
	var books []models.BookInventory
	title := c.Query("title")
	author := c.Query("authors")
	publisher := c.Query("publisher")

	query := config.DB

	if title != "" {
		query = query.Where("title LIKE ?", "%"+title+"%")
	}
	if author != "" {
		query = query.Where("authors LIKE ?", "%"+author+"%")
	}
	if publisher != "" {
		query = query.Where("publisher LIKE ?", "%"+publisher+"%")
	}

	query.Find(&books)

	// for i, book := range books {
	// 	if book.AvailableCopies > 0 {
	// 		books[i].Status = "Available"
	// 	} else {
	// 		books[i].Status = "Not available, expected by " + book.ExpectedReturnDate.Format("2006-01-02")
	// 	}
	// }

	utils.RespondJSON(c, http.StatusOK, "Books retrieved successfully", books)
}

/home/xs535-himary/library/controllers/issuesController.go

package controllers

import (
	"library/config"
	"library/models"

	"library/utils"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
)

// Get All Issues
func GetIssues(c *gin.Context) {
	var issues []models.IssueRegistery
	config.DB.Find(&issues)
	utils.RespondJSON(c, http.StatusOK, "All Issues Retrieved.", issues)
}

// Issue Book
func IssueBook(c *gin.Context) {
	var request models.RequestEvent
	id := c.Param("id")

	if err := config.DB.First(&request, id).Error; err != nil {
		utils.RespondJSON(c, http.StatusNotFound, "Request not found", nil)
		return
	}

	// Fetch book inventory
	var book models.BookInventory
	if err := config.DB.Where("isbn = ?", request.ISBN).First(&book).Error; err != nil {
		utils.RespondJSON(c, http.StatusNotFound, "Book not found", nil)
		return
	}

	// Check if the book is available
	if book.AvailableCopies <= 0 {
		utils.RespondJSON(c, http.StatusConflict, "No available copies for this book", nil)
		return
	}

	// Update book inventory (decrease available copies)
	book.AvailableCopies--
	if err := config.DB.Save(&book).Error; err != nil {
		utils.RespondJSON(c, http.StatusInternalServerError, "Failed to update book inventory", nil)
		return
	}

	// // Assuming middleware sets user_id in context
	IssueApproverID, exists := c.Get("user_id")
	if !exists {
		utils.RespondJSON(c, http.StatusUnauthorized, "User ID not found in context", nil)
		return
	}

	//Update RequestEvent
	// request.ApprovalDate = time.Now()
	// request.ApproverID = &IssueApproverIDUint
	request.IssueStatus = "Issued"
	if err := config.DB.Save(&request).Error; err != nil {
		utils.RespondJSON(c, http.StatusInternalServerError, "Error", gin.H{"error": err.Error()})
		return
	}

	// Insert new record in IssueRegistry
	issue := models.IssueRegistery{
		ISBN:               request.ISBN,
		ReaderID:           request.ReaderID,
		IssueApproverID:    IssueApproverID.(uint),
		IssueStatus:        "Issued",
		IssueDate:          time.Now().Format("2006-01-02 15:04:05"),          // in format "2006-01-02 15:04:05"
		ExpectedReturnDate: time.Now().AddDate(0, 0, 14).Format("2006-01-02"), // Default 2-week return period
	}

	if err := config.DB.Create(&issue).Error; err != nil {
		utils.RespondJSON(c, http.StatusInternalServerError, "Failed to issue book", nil)
		return
	}

	utils.RespondJSON(c, http.StatusOK, "Book issued successfully", issue)
}

// Return Book by isbn and reader_id from isuue_registery
func ReturnBook(c *gin.Context) {
	id := c.Param("id")

	var issue models.IssueRegistery
	if err := config.DB.Where("isbn = ?", id).First(&issue).Error; err != nil {
		utils.RespondJSON(c, http.StatusNotFound, "Issue record not found", nil)
		return
	}

	// Check if the book is already returned
	if issue.IssueStatus == "Returned" {
		utils.RespondJSON(c, http.StatusConflict, "Book already returned", nil)
		return
	}

	// Check if readerid is same as the logged in user
	readerID, exists := c.Get("user_id")
	if !exists {
		utils.RespondJSON(c, http.StatusUnauthorized, "User ID not found in context", nil)
		return
	}
	readerIDUint, ok := readerID.(uint)
	if !ok {
		utils.RespondJSON(c, http.StatusInternalServerError, "Failed to cast user ID", nil)
		return
	}
	if issue.ReaderID != readerIDUint {
		utils.RespondJSON(c, http.StatusUnauthorized, "You are not authorized to return this book", nil)
		return
	}

	// Update issue record with return date
	now := time.Now()
	issue.ReturnDate = now.Format("2006-01-02 15:04:05")
	issue.IssueStatus = "Returned"

	if err := config.DB.Save(&issue).Error; err != nil {
		utils.RespondJSON(c, http.StatusInternalServerError, "Failed to update issue record", nil)
		return
	}

	// Update book inventory (increase available copies)
	var book models.BookInventory
	if err := config.DB.Where("isbn = ?", issue.ISBN).First(&book).Error; err != nil {
		utils.RespondJSON(c, http.StatusNotFound, "Book inventory record not found", nil)
		return
	}

	book.AvailableCopies++
	if err := config.DB.Save(&book).Error; err != nil {
		utils.RespondJSON(c, http.StatusInternalServerError, "Failed to update book inventory", nil)
		return
	}

	//update the requestType in requestEvent
	var request models.RequestEvent
	if err := config.DB.Where("isbn = ?", issue.ISBN).First(&request).Error; err != nil {
		utils.RespondJSON(c, http.StatusNotFound, "Request record not found", nil)
		return
	}
	request.RequestType = "Return"
	if err := config.DB.Save(&request).Error; err != nil {
		utils.RespondJSON(c, http.StatusInternalServerError, "Failed to update request record", nil)
		return
	}

	// utils.RespondJSON(c, http.StatusOK, "Book returned successfully", gin.H{"issue": issue, "book": book, "request": request})
	utils.RespondJSON(c, http.StatusOK, "Book returned successfully", nil)
}

/home/xs535-himary/library/controllers/libraryController.go

package controllers

import (
	"library/config"
	"library/models"
	"library/utils"
	"net/http"

	"github.com/gin-gonic/gin"
)

func CreateLibrary(c *gin.Context) {
	var library models.Library
	if err := c.ShouldBindJSON(&library); err != nil {
		utils.RespondJSON(c, http.StatusBadRequest, "Invalid input", nil)
		return
	}

	if err := config.DB.Create(&library).Error; err != nil {
		utils.RespondJSON(c, http.StatusInternalServerError, "Failed to create library", err.Error())
		return
	}

	//find user by id for Updating user lib_id and Role  // reader -> owner
	var user models.User
	if err := config.DB.First(&user, c.GetUint("user_id")).Error; err != nil {
		utils.RespondJSON(c, http.StatusNotFound, "User not found", nil)
		return
	}

	user.LibID = library.ID
	user.Role = "owner"

	if err := config.DB.Save(&user).Error; err != nil {
		utils.RespondJSON(c, http.StatusInternalServerError, "Failed to update user", nil)
		return
	}

	//Sending response
	data := gin.H{"library": library, "Owner Of Library": user.Name, "Role": user.Role}

	utils.RespondJSON(c, http.StatusCreated, "Library created successfully", data)
}

func GetLibraries(c *gin.Context) {
	var libraries []models.Library
	config.DB.Find(&libraries)
	utils.RespondJSON(c, http.StatusOK, "Libraries fetched successfully", libraries)
}

func UpdateLibrary(c *gin.Context) {
	var library models.Library
	libraryID := c.Param("id")

	if err := config.DB.First(&library, libraryID).Error; err != nil {
		utils.RespondJSON(c, http.StatusNotFound, "Library not found", nil)
		return
	}

	if err := c.ShouldBindJSON(&library); err != nil {
		utils.RespondJSON(c, http.StatusBadRequest, "Invalid input", nil)
		return
	}

	if err := config.DB.Save(&library).Error; err != nil {
		utils.RespondJSON(c, http.StatusInternalServerError, "Failed to update library", nil)
		return
	}

	utils.RespondJSON(c, http.StatusOK, "Library updated successfully", library)
}

func DeleteLibrary(c *gin.Context) {
	var library models.Library
	libraryID := c.Param("id")

	if err := config.DB.First(&library, libraryID).Error; err != nil {
		utils.RespondJSON(c, http.StatusNotFound, "Library not found", nil)
		return
	}

	if err := config.DB.Delete(&library).Error; err != nil {
		utils.RespondJSON(c, http.StatusInternalServerError, "Failed to delete library", nil)
		return
	}

	utils.RespondJSON(c, http.StatusOK, "Library deleted successfully", nil)
}

/home/xs535-himary/library/controllers/requestController.go

package controllers

import (
	"library/config"
	"library/models"
	"library/utils"

	"net/http"
	"time"

	"github.com/gin-gonic/gin"
)

// Get All Requests
func GetRequests(c *gin.Context) {
	var requests []models.RequestEvent
	config.DB.Find(&requests)

	//if requwsts is empty
	if len(requests) == 0 {
		utils.RespondJSON(c, http.StatusNotFound, "No Requests Found", nil)
		return
	}

	utils.RespondJSON(c, http.StatusOK, "All Requests", requests)
}

// Create Request
func CreateRequest(c *gin.Context) {
	var request models.RequestEvent
	if err := c.ShouldBindJSON(&request); err != nil {
		utils.RespondJSON(c, http.StatusBadRequest, "Cannot Bind JSON Data", gin.H{"error": err.Error()})
		return
	}

	//Finding Book by ISBN
	var book models.BookInventory
	if err := config.DB.Where("isbn = ?", request.ISBN).First(&book).Error; err != nil {
		utils.RespondJSON(c, http.StatusNotFound, "Book not found", nil)
		return
	}

	//Checking if book is available
	if book.AvailableCopies <= 0 {
		utils.RespondJSON(c, http.StatusConflict, "Request Cannot be made !!, Book is not available.", nil)
		return
	}

	// Because reader is creating the request
	// Assuming middleware sets user_id in context
	readerID, exists := c.Get("user_id")
	if !exists {
		utils.RespondJSON(c, http.StatusUnauthorized, "Reader ID not found in context", nil)
		return
	}
	readerIDUint, ok := readerID.(uint)
	if !ok {
		utils.RespondJSON(c, http.StatusInternalServerError, "Failed to cast Reader Id", nil)
		return
	}

	request.ReaderID = readerIDUint

	//checking if user has already requested for the book
	var existingRequest models.RequestEvent
	if err := config.DB.Where("isbn = ? AND reader_id = ? AND approval_date IS NULL", request.ISBN, request.ReaderID).First(&existingRequest).Error; err == nil {
		utils.RespondJSON(c, http.StatusConflict, "Request already exists", nil)
		return
	}

	request.ReaderID = readerIDUint
	request.RequestDate = time.Now().Format("2006-01-02 15:04:05")
	request.RequestType = "Borrow"
	request.IssueStatus = "Pending"

	if err := config.DB.Create(&request).Error; err != nil {
		utils.RespondJSON(c, http.StatusInternalServerError, "Cannot create request", gin.H{"error": err.Error()})
		return
	}

	utils.RespondJSON(c, http.StatusCreated, "Request Created", request)
}

// Approve Request
func ApproveRequest(c *gin.Context) {
	var request models.RequestEvent
	id := c.Param("id")

	if err := config.DB.First(&request, id).Error; err != nil {
		// c.JSON(http.StatusNotFound, gin.H{"error": "Request not found"})
		utils.RespondJSON(c, http.StatusNotFound, "Request not found", nil)
		return
	}

	// // Assuming middleware sets user_id in context
	// approverID := c.GetUint("user_id")
	approverID, exists := c.Get("user_id")
	if !exists {
		utils.RespondJSON(c, http.StatusUnauthorized, "User ID not found in context", nil)
		return
	}
	approverIDUint, ok := approverID.(uint)
	if !ok {
		utils.RespondJSON(c, http.StatusInternalServerError, "Failed to cast user ID", nil)
		return
	}

	now := time.Now()
	request.ApprovalDate = &now
	request.ApproverID = &approverIDUint
	request.IssueStatus = "Approved"

	if err := config.DB.Save(&request).Error; err != nil {
		utils.RespondJSON(c, http.StatusInternalServerError, "Error", gin.H{"error": err.Error()})
		return
	}

	utils.RespondJSON(c, http.StatusOK, "All Requests", request)
}

// Approve And Issue Request
func ApproveAndIssueRequest(c *gin.Context) {
	var request models.RequestEvent
	id := c.Param("id")
	if err := config.DB.First(&request, id).Error; err != nil {
		utils.RespondJSON(c, http.StatusNotFound, "Request not found", nil)
		return
	}

	// Fetch book inventory
	var book models.BookInventory
	if err := config.DB.Where("isbn = ?", request.ISBN).First(&book).Error; err != nil {
		utils.RespondJSON(c, http.StatusNotFound, "Book not found", nil)
		return
	}
	// Check if the book is available
	if book.AvailableCopies <= 0 {
		utils.RespondJSON(c, http.StatusConflict, "No available copies for this book", nil)
		return
	}
	// Update book inventory (decrease available copies)
	book.AvailableCopies--
	if err := config.DB.Save(&book).Error; err != nil {
		utils.RespondJSON(c, http.StatusInternalServerError, "Failed to update book inventory", nil)
		return
	}

	// // Assuming middleware sets user_id in context
	approverID, exists := c.Get("user_id")
	if !exists {
		utils.RespondJSON(c, http.StatusUnauthorized, "User ID not found in context", nil)
		return
	}
	approverIDUint, ok := approverID.(uint)
	if !ok {
		utils.RespondJSON(c, http.StatusInternalServerError, "Failed to cast user ID", nil)
		return
	}

	now := time.Now()
	request.ApprovalDate = &now
	request.ApproverID = &approverIDUint
	request.IssueStatus = "Approved And Issued"

	if err := config.DB.Save(&request).Error; err != nil {
		utils.RespondJSON(c, http.StatusInternalServerError, "Error", gin.H{"error": err.Error()})
		return
	}

	// utils.RespondJSON(c, http.StatusOK, "All Requests", request)

	// Insert new record in IssueRegistry
	issue := models.IssueRegistery{
		ISBN:               request.ISBN,
		ReaderID:           request.ReaderID,
		IssueApproverID:    *request.ApproverID,
		IssueStatus:        "Issued",
		IssueDate:          time.Now().Format("2006-01-02 15:04:05"),          // in format "2006-01-02 15:04:05"
		ExpectedReturnDate: time.Now().AddDate(0, 0, 14).Format("2006-01-02"), // Default 2-week return period
	}
	if err := config.DB.Create(&issue).Error; err != nil {
		utils.RespondJSON(c, http.StatusInternalServerError, "Failed to issue book", nil)
		return
	}
	utils.RespondJSON(c, http.StatusOK, "Book issued and approved successfully", nil)
}

/home/xs535-himary/library/middlewares/authMiddleware.go

package middlewares

import (
	"library/config"
	"library/models"
	"library/utils"
	"net/http"

	"github.com/gin-gonic/gin"
)
func AuthMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		authorizationHeader := c.GetHeader("Authorization")

		// Check if the Authorization header is empty or too short
		if len(authorizationHeader) < 8 || authorizationHeader[:7] != "Bearer " {
			utils.RespondJSON(c, http.StatusUnauthorized, "Authorization token is required", nil)
			c.Abort()
			return
		}

		// Extract token
		token := authorizationHeader[7:]

		// Check if token is empty
		if token == "" {
			utils.RespondJSON(c, http.StatusUnauthorized, "Invalid token format", nil)
			c.Abort()
			return
		}

		// Validate JWT token
		claims, err := utils.ParseToken(token)
		if err != nil {
			utils.RespondJSON(c, http.StatusUnauthorized, "Invalid token", nil)
			c.Abort()
			return
		}

		// Check session in DB
		var session models.Session
		if err := config.DB.Where("token = ? AND is_active = ?", token, true).First(&session).Error; err != nil {
			utils.RespondJSON(c, http.StatusUnauthorized, "Session expired or invalid", nil)
			c.Abort()
			return
		}

		// Set user details in context for future use
		c.Set("user_id", claims.UserID)
		c.Set("email", claims.Email)
		c.Set("role", claims.Role)
		c.Next()
	}
}


/home/xs535-himary/library/middlewares/roleMiddleware.go

package middlewares

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

// RoleMiddleware checks if the user has one of the allowed roles
func RoleMiddleware(allowedRoles ...string) gin.HandlerFunc {
	return func(c *gin.Context) {
		role, exists := c.Get("role")
		if !exists {
			c.JSON(http.StatusForbidden, gin.H{"error": "Unauthorized access"})
			c.Abort()
			return
		}

		// Convert role to string (in case it's stored differently)
		userRole, ok := role.(string)
		if !ok {
			c.JSON(http.StatusForbidden, gin.H{"error": "Unauthorized access"})
			c.Abort()
			return
		}

		// Check if user role is in allowedRoles
		for _, allowedRole := range allowedRoles {
			if userRole == allowedRole {
				c.Next()
				return
			}
		}

		// If no match, reject access
		c.JSON(http.StatusForbidden, gin.H{"error": "Unauthorized access"})
		c.Abort()
	}
}


/home/xs535-himary/library/models/libraryModel.go

package models

import (
	"time"
)

// User Table
type User struct {
	ID            uint   `gorm:"primaryKey" json:"id"`
	Name          string `json:"name" binding:"required"`
	Email         string `gorm:"unique" json:"email" binding:"required,email"`
	ContactNumber string `gorm:"unique" json:"contact_number" binding:"required,len=10,numeric"`
	Password      string `json:"password" binding:"required"`
	Role          string `gorm:"default:'reader'" json:"role,omitempty"`
	LibID         uint   `json:"lib_id,omitempty"`
}

// Library Table
type Library struct {
	ID   uint   `gorm:"primaryKey" json:"id"`
	Name string `gorm:"unique" json:"name"`
}

type BookInventory struct {
	BookID          uint   `gorm:"primaryKey;autoIncrement" json:"book_id"`
	ISBN            string `gorm:"primaryKey;autoIncrement:false" json:"isbn"`
	LibID           uint   `json:"lib_id,omitempty"`
	Title           string `gorm:"unique" json:"title"`
	Authors         string `json:"authors"`
	Publisher       string `json:"publisher"`
	Version         string `json:"version"`
	TotalCopies     int    `json:"total_copies"`
	AvailableCopies int    `json:"available_copies"`
}

// Request Table
type RequestEvent struct {
	ReqID        uint       `gorm:"primaryKey;autoIncrement" json:"req_id"`
	ISBN         string     `gorm:"not null" json:"isbn"`
	ReaderID     uint       `gorm:"not null" json:"reader_id"`
	RequestDate  string     `gorm:"autoCreateTime" json:"request_date"`
	ApprovalDate *time.Time `json:"approval_date,omitempty"`
	ApproverID   *uint      `json:"approver_id,omitempty"`
	RequestType  string     `gorm:"not null" json:"request_type"`           // e.g., "Borrow", "Return"
	IssueStatus  string     `gorm:"not null" json:"issue_status,omitempty"` // e.g., "Issued and Approved"
}

// Issues Table
type IssueRegistery struct {
	IssueID            uint   `gorm:"primaryKey;autoIncrement" json:"issue_id"`
	ISBN               string `gorm:"not null" json:"isbn"`
	ReaderID           uint   `gorm:"not null" json:"reader_id"`
	IssueApproverID    uint   `gorm:"not null" json:"issue_approver_id"`
	IssueStatus        string `gorm:"not null" json:"issue_status"` // e.g., "Issued", "Returned"
	IssueDate          string `gorm:"autoCreateTime" json:"issue_date"`
	ExpectedReturnDate string `json:"expected_return_date"`
	ReturnDate         string `json:"return_date,omitempty"`
	ReturnApproverID   *uint  `json:"return_approver_id,omitempty"`
}


/home/xs535-himary/library/models/sessionModel.go

// models/session.go
package models

import (
	"time"
	// "gorm.io/gorm"
)

type Session struct {
	ID        uint           `gorm:"primaryKey"`
	UserID    uint           `gorm:"index"`
	Token     string         `gorm:"unique"`
	ExpiresAt time.Time
	IsActive  bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

/home/xs535-himary/library/routes/routes.go

package routes

import (
	"library/controllers"
	"library/middlewares"

	"github.com/gin-gonic/gin"
)

func Routes(router *gin.Engine) {
	//Auth Routes
	router.POST("/signup", controllers.SignUp)   // Create User
	router.POST("/signin", controllers.SignIn)   // Login User
	router.POST("/signout", controllers.SignOut) // Logout User

	router.GET("/users", controllers.GetUsers)             // Get all Users
	router.GET("/user/:id", controllers.GetUserById)       // Get User By ID
	router.PUT("/user/:id", controllers.UpdateUserById)    // Update User By ID
	router.DELETE("/user/:id", controllers.DeleteUserById) // Delete User By ID

	// Library Routes
	router.GET("/library", controllers.GetLibraries) // Get all Libraries
	libraryGroup := router.Group("/")
	libraryGroup.Use(middlewares.AuthMiddleware())
	{
		libraryGroup.POST("/library/", controllers.CreateLibrary)                                                    // Create Library
		libraryGroup.PUT("/library/:id", middlewares.RoleMiddleware("owner"), controllers.UpdateLibrary)             // Update Library
		libraryGroup.DELETE("/library/:id", middlewares.RoleMiddleware("owner", "admin"), controllers.DeleteLibrary) // Delete Library
	}

	// Book Routes
	router.GET("/search", controllers.SearchBooks)   // Search Books by Title, Authors, Publisher
	router.GET("/books", controllers.GetBooks)       // Get All Books
	router.GET("/book/:id", controllers.GetBookByID) // Get Book By ID
	bookGroup := router.Group("/")
	bookGroup.Use(middlewares.AuthMiddleware())
	{
		bookGroup.POST("/book", middlewares.RoleMiddleware("owner"), controllers.CreateBook)                    // Create Book By Owner Only Because Owner has LibID
		bookGroup.PUT("/book/:id", middlewares.RoleMiddleware("owner"), controllers.UpdateBookByID)             // Update Book By Owner Only Because Owner has LibID
		bookGroup.DELETE("/book/:id", middlewares.RoleMiddleware("owner", "admin"), controllers.DeleteBookByID) // Delete Book By Owner and Admin Only not by Reader
	}

	// Request Issues Return Routes
	requestAndIssuesGroup := router.Group("/")
	requestAndIssuesGroup.Use(middlewares.AuthMiddleware())
	{
		requestAndIssuesGroup.GET("/requests", controllers.GetRequests)                                                          // Get all requests
		requestAndIssuesGroup.GET("/issues", controllers.GetIssues)                                                              // Get all issues
		requestAndIssuesGroup.POST("/request", middlewares.RoleMiddleware("reader"), controllers.CreateRequest)                  // Create Request
		requestAndIssuesGroup.PUT("/approve-issue/:id", middlewares.RoleMiddleware("admin"), controllers.ApproveAndIssueRequest) // Approve Request and Issue Book
		requestAndIssuesGroup.PUT("/return/:id", middlewares.RoleMiddleware("reader"), controllers.ReturnBook)                   // Return book by isbn
		// requestAndIssuesGroup.PUT("/approve/:id", middlewares.RoleMiddleware("admin"), controllers.ApproveRequest)
	}
}


/home/xs535-himary/library/utils/hash.go

package utils

import "golang.org/x/crypto/bcrypt"

// HashPassword generates a hashed password
func HashPassword(password string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
	return string(bytes), err
}

// CheckPasswordHash verifies the hashed password
func CheckPasswordHash(password, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
	return err == nil
}


/home/xs535-himary/library/utils/jwt.go

package utils

import (
	"errors"
	"os"
	"time"

	"github.com/golang-jwt/jwt/v4"
	"github.com/joho/godotenv"
)

var secretKey []byte

func init() {
	godotenv.Load()
	secretKey = []byte(os.Getenv("JWT_SECRET"))
}

// Claims struct for JWT payload
type Claims struct {
	UserID uint   `json:"user_id"`
	Email  string `json:"email"`
	Role   string `json:"role"`
	jwt.RegisteredClaims
}

// GenerateJWT creates a new JWT token
func GenerateJWT(userID uint, email, role string) (string, error) {
	token := jwt.New(jwt.SigningMethodHS256)
	claims := token.Claims.(jwt.MapClaims)
	claims["user_id"] = userID // Add the user_id to the claims
	claims["email"] = email
	claims["role"] = role
	claims["exp"] = time.Now().Add(time.Hour * 24).Unix()
	// claims["exp"] = time.Now().Add(time.Minute * 1).Unix()

	tokenString, err := token.SignedString(secretKey)
	if err != nil {
		return "", err
	}
	return tokenString, nil
}

// ParseToken validates and extracts claims from the JWT token
func ParseToken(tokenString string) (*Claims, error) {
	// Parse token with Claims struct
	token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
		return secretKey, nil
	})

	if err != nil {
		return nil, err
	}

	// Extract claims safely
	claims, ok := token.Claims.(*Claims)
	if !ok || !token.Valid {
		return nil, errors.New("invalid token")
	}

	return claims, nil
}


/home/xs535-himary/library/utils/response.go

package utils

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

// APIResponse formats the JSON response for API endpoints
func APIResponse(c *gin.Context, status int, message string, data interface{}) {
	c.JSON(status, gin.H{
		"Status":  status,
		"Message": message,
		"Data":    data,
	})
}

// JSONResponse represents the structure of a standard API response
type JSONResponse struct {
	Status     string      `json:"status"`
	StatusCode int         `json:"statusCode"`
	Message    string      `json:"message"`
	Data       interface{} `json:"data,omitempty"`
}

// RespondJSON sends a JSON response with a given status code
func RespondJSON(c *gin.Context, statusCode int, message string, data interface{}) {
	response := JSONResponse{
		Status:     "success",
		StatusCode: statusCode,
		Message:    message,
		Data:       data,
	}

	if statusCode >= http.StatusBadRequest {
		response.Status = "error"
	}

	c.JSON(statusCode, response)
}
